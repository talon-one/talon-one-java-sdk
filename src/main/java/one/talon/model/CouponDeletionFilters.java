/*
 * Talon.One API
 * Use the Talon.One API to integrate with your application and to manage applications and campaigns:  - Use the operations in the [Integration API section](#integration-api) are used to integrate with our platform - Use the operation in the [Management API section](#management-api) to manage applications and campaigns.  ## Determining the base URL of the endpoints  The API is available at the same hostname as your Campaign Manager deployment. For example, if you access the Campaign Manager at `https://yourbaseurl.talon.one/`, the URL for the [updateCustomerSessionV2](https://docs.talon.one/integration-api#operation/updateCustomerSessionV2) endpoint is `https://yourbaseurl.talon.one/v2/customer_sessions/{Id}` 
 *
 * The version of the OpenAPI document: 
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package one.talon.model;

import java.util.Objects;
import java.util.Locale;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Locale;

import one.talon.JSON;

/**
 * CouponDeletionFilters
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", comments = "Generator version: 7.17.0")
public class CouponDeletionFilters {
  public static final String SERIALIZED_NAME_CREATED_BEFORE = "createdBefore";
  @SerializedName(SERIALIZED_NAME_CREATED_BEFORE)
  @javax.annotation.Nullable
  private OffsetDateTime createdBefore;

  public static final String SERIALIZED_NAME_CREATED_AFTER = "createdAfter";
  @SerializedName(SERIALIZED_NAME_CREATED_AFTER)
  @javax.annotation.Nullable
  private OffsetDateTime createdAfter;

  public static final String SERIALIZED_NAME_STARTS_AFTER = "startsAfter";
  @SerializedName(SERIALIZED_NAME_STARTS_AFTER)
  @javax.annotation.Nullable
  private OffsetDateTime startsAfter;

  public static final String SERIALIZED_NAME_STARTS_BEFORE = "startsBefore";
  @SerializedName(SERIALIZED_NAME_STARTS_BEFORE)
  @javax.annotation.Nullable
  private OffsetDateTime startsBefore;

  /**
   * - &#x60;expired&#x60;: Matches coupons in which the expiration date is set and in the past. - &#x60;validNow&#x60;: Matches coupons in which the start date is null or in the past and the expiration date is null or in the future. - &#x60;validFuture&#x60;: Matches coupons in which the start date is set and in the future. 
   */
  @JsonAdapter(ValidEnum.Adapter.class)
  public enum ValidEnum {
    EXPIRED("expired"),
    
    VALID_NOW("validNow"),
    
    VALID_FUTURE("validFuture");

    private String value;

    ValidEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ValidEnum fromValue(String value) {
      for (ValidEnum b : ValidEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ValidEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ValidEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ValidEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ValidEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ValidEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_VALID = "valid";
  @SerializedName(SERIALIZED_NAME_VALID)
  @javax.annotation.Nullable
  private ValidEnum valid;

  public static final String SERIALIZED_NAME_USABLE = "usable";
  @SerializedName(SERIALIZED_NAME_USABLE)
  @javax.annotation.Nullable
  private Boolean usable;

  public static final String SERIALIZED_NAME_REDEEMED = "redeemed";
  @SerializedName(SERIALIZED_NAME_REDEEMED)
  @javax.annotation.Nullable
  private Boolean redeemed;

  public static final String SERIALIZED_NAME_RECIPIENT_INTEGRATION_ID = "recipientIntegrationId";
  @SerializedName(SERIALIZED_NAME_RECIPIENT_INTEGRATION_ID)
  @javax.annotation.Nullable
  private String recipientIntegrationId;

  public static final String SERIALIZED_NAME_EXACT_MATCH = "exactMatch";
  @SerializedName(SERIALIZED_NAME_EXACT_MATCH)
  @javax.annotation.Nullable
  private Boolean exactMatch = false;

  public static final String SERIALIZED_NAME_VALUE = "value";
  @SerializedName(SERIALIZED_NAME_VALUE)
  @javax.annotation.Nullable
  private String value;

  public static final String SERIALIZED_NAME_BATCH_ID = "batchId";
  @SerializedName(SERIALIZED_NAME_BATCH_ID)
  @javax.annotation.Nullable
  private String batchId;

  public static final String SERIALIZED_NAME_REFERRAL_ID = "referralId";
  @SerializedName(SERIALIZED_NAME_REFERRAL_ID)
  @javax.annotation.Nullable
  private Long referralId;

  public static final String SERIALIZED_NAME_EXPIRES_AFTER = "expiresAfter";
  @SerializedName(SERIALIZED_NAME_EXPIRES_AFTER)
  @javax.annotation.Nullable
  private OffsetDateTime expiresAfter;

  public static final String SERIALIZED_NAME_EXPIRES_BEFORE = "expiresBefore";
  @SerializedName(SERIALIZED_NAME_EXPIRES_BEFORE)
  @javax.annotation.Nullable
  private OffsetDateTime expiresBefore;

  public CouponDeletionFilters() {
  }

  public CouponDeletionFilters createdBefore(@javax.annotation.Nullable OffsetDateTime createdBefore) {
    this.createdBefore = createdBefore;
    return this;
  }

  /**
   * Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. You can use any time zone setting. Talon.One will convert to UTC internally.
   * @return createdBefore
   */
  @javax.annotation.Nullable
  public OffsetDateTime getCreatedBefore() {
    return createdBefore;
  }

  public void setCreatedBefore(@javax.annotation.Nullable OffsetDateTime createdBefore) {
    this.createdBefore = createdBefore;
  }


  public CouponDeletionFilters createdAfter(@javax.annotation.Nullable OffsetDateTime createdAfter) {
    this.createdAfter = createdAfter;
    return this;
  }

  /**
   * Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. You can use any time zone setting. Talon.One will convert to UTC internally.
   * @return createdAfter
   */
  @javax.annotation.Nullable
  public OffsetDateTime getCreatedAfter() {
    return createdAfter;
  }

  public void setCreatedAfter(@javax.annotation.Nullable OffsetDateTime createdAfter) {
    this.createdAfter = createdAfter;
  }


  public CouponDeletionFilters startsAfter(@javax.annotation.Nullable OffsetDateTime startsAfter) {
    this.startsAfter = startsAfter;
    return this;
  }

  /**
   * Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. You can use any time zone setting. Talon.One will convert to UTC internally.
   * @return startsAfter
   */
  @javax.annotation.Nullable
  public OffsetDateTime getStartsAfter() {
    return startsAfter;
  }

  public void setStartsAfter(@javax.annotation.Nullable OffsetDateTime startsAfter) {
    this.startsAfter = startsAfter;
  }


  public CouponDeletionFilters startsBefore(@javax.annotation.Nullable OffsetDateTime startsBefore) {
    this.startsBefore = startsBefore;
    return this;
  }

  /**
   * Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. You can use any time zone setting. Talon.One will convert to UTC internally.
   * @return startsBefore
   */
  @javax.annotation.Nullable
  public OffsetDateTime getStartsBefore() {
    return startsBefore;
  }

  public void setStartsBefore(@javax.annotation.Nullable OffsetDateTime startsBefore) {
    this.startsBefore = startsBefore;
  }


  public CouponDeletionFilters valid(@javax.annotation.Nullable ValidEnum valid) {
    this.valid = valid;
    return this;
  }

  /**
   * - &#x60;expired&#x60;: Matches coupons in which the expiration date is set and in the past. - &#x60;validNow&#x60;: Matches coupons in which the start date is null or in the past and the expiration date is null or in the future. - &#x60;validFuture&#x60;: Matches coupons in which the start date is set and in the future. 
   * @return valid
   */
  @javax.annotation.Nullable
  public ValidEnum getValid() {
    return valid;
  }

  public void setValid(@javax.annotation.Nullable ValidEnum valid) {
    this.valid = valid;
  }


  public CouponDeletionFilters usable(@javax.annotation.Nullable Boolean usable) {
    this.usable = usable;
    return this;
  }

  /**
   * - &#x60;true&#x60;: only coupons where &#x60;usageCounter &lt; usageLimit&#x60; will be returned. - &#x60;false&#x60;: only coupons where &#x60;usageCounter &gt;&#x3D; usageLimit&#x60; will be returned. - This field cannot be used in conjunction with the &#x60;usable&#x60; query parameter. 
   * @return usable
   */
  @javax.annotation.Nullable
  public Boolean getUsable() {
    return usable;
  }

  public void setUsable(@javax.annotation.Nullable Boolean usable) {
    this.usable = usable;
  }


  public CouponDeletionFilters redeemed(@javax.annotation.Nullable Boolean redeemed) {
    this.redeemed = redeemed;
    return this;
  }

  /**
   * - &#x60;true&#x60;: only coupons where &#x60;usageCounter &gt; 0&#x60; will be returned. - &#x60;false&#x60;: only coupons where &#x60;usageCounter &#x3D; 0&#x60; will be returned.  **Note:** This field cannot be used in conjunction with the &#x60;usable&#x60; query parameter. 
   * @return redeemed
   */
  @javax.annotation.Nullable
  public Boolean getRedeemed() {
    return redeemed;
  }

  public void setRedeemed(@javax.annotation.Nullable Boolean redeemed) {
    this.redeemed = redeemed;
  }


  public CouponDeletionFilters recipientIntegrationId(@javax.annotation.Nullable String recipientIntegrationId) {
    this.recipientIntegrationId = recipientIntegrationId;
    return this;
  }

  /**
   * Filter results by match with a profile id specified in the coupon&#39;s &#x60;RecipientIntegrationId&#x60; field. 
   * @return recipientIntegrationId
   */
  @javax.annotation.Nullable
  public String getRecipientIntegrationId() {
    return recipientIntegrationId;
  }

  public void setRecipientIntegrationId(@javax.annotation.Nullable String recipientIntegrationId) {
    this.recipientIntegrationId = recipientIntegrationId;
  }


  public CouponDeletionFilters exactMatch(@javax.annotation.Nullable Boolean exactMatch) {
    this.exactMatch = exactMatch;
    return this;
  }

  /**
   * Filter results to an exact case-insensitive matching against the coupon code
   * @return exactMatch
   */
  @javax.annotation.Nullable
  public Boolean getExactMatch() {
    return exactMatch;
  }

  public void setExactMatch(@javax.annotation.Nullable Boolean exactMatch) {
    this.exactMatch = exactMatch;
  }


  public CouponDeletionFilters value(@javax.annotation.Nullable String value) {
    this.value = value;
    return this;
  }

  /**
   * Filter results by the coupon code
   * @return value
   */
  @javax.annotation.Nullable
  public String getValue() {
    return value;
  }

  public void setValue(@javax.annotation.Nullable String value) {
    this.value = value;
  }


  public CouponDeletionFilters batchId(@javax.annotation.Nullable String batchId) {
    this.batchId = batchId;
    return this;
  }

  /**
   * Filter results by batches of coupons
   * @return batchId
   */
  @javax.annotation.Nullable
  public String getBatchId() {
    return batchId;
  }

  public void setBatchId(@javax.annotation.Nullable String batchId) {
    this.batchId = batchId;
  }


  public CouponDeletionFilters referralId(@javax.annotation.Nullable Long referralId) {
    this.referralId = referralId;
    return this;
  }

  /**
   * Filter the results by matching them with the ID of a referral. This filter shows the coupons created by redeeming a referral code.
   * @return referralId
   */
  @javax.annotation.Nullable
  public Long getReferralId() {
    return referralId;
  }

  public void setReferralId(@javax.annotation.Nullable Long referralId) {
    this.referralId = referralId;
  }


  public CouponDeletionFilters expiresAfter(@javax.annotation.Nullable OffsetDateTime expiresAfter) {
    this.expiresAfter = expiresAfter;
    return this;
  }

  /**
   * Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. You can use any time zone setting. Talon.One will convert to UTC internally.
   * @return expiresAfter
   */
  @javax.annotation.Nullable
  public OffsetDateTime getExpiresAfter() {
    return expiresAfter;
  }

  public void setExpiresAfter(@javax.annotation.Nullable OffsetDateTime expiresAfter) {
    this.expiresAfter = expiresAfter;
  }


  public CouponDeletionFilters expiresBefore(@javax.annotation.Nullable OffsetDateTime expiresBefore) {
    this.expiresBefore = expiresBefore;
    return this;
  }

  /**
   * Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp. You can use any time zone setting. Talon.One will convert to UTC internally.
   * @return expiresBefore
   */
  @javax.annotation.Nullable
  public OffsetDateTime getExpiresBefore() {
    return expiresBefore;
  }

  public void setExpiresBefore(@javax.annotation.Nullable OffsetDateTime expiresBefore) {
    this.expiresBefore = expiresBefore;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    CouponDeletionFilters couponDeletionFilters = (CouponDeletionFilters) o;
    return Objects.equals(this.createdBefore, couponDeletionFilters.createdBefore) &&
        Objects.equals(this.createdAfter, couponDeletionFilters.createdAfter) &&
        Objects.equals(this.startsAfter, couponDeletionFilters.startsAfter) &&
        Objects.equals(this.startsBefore, couponDeletionFilters.startsBefore) &&
        Objects.equals(this.valid, couponDeletionFilters.valid) &&
        Objects.equals(this.usable, couponDeletionFilters.usable) &&
        Objects.equals(this.redeemed, couponDeletionFilters.redeemed) &&
        Objects.equals(this.recipientIntegrationId, couponDeletionFilters.recipientIntegrationId) &&
        Objects.equals(this.exactMatch, couponDeletionFilters.exactMatch) &&
        Objects.equals(this.value, couponDeletionFilters.value) &&
        Objects.equals(this.batchId, couponDeletionFilters.batchId) &&
        Objects.equals(this.referralId, couponDeletionFilters.referralId) &&
        Objects.equals(this.expiresAfter, couponDeletionFilters.expiresAfter) &&
        Objects.equals(this.expiresBefore, couponDeletionFilters.expiresBefore);
  }

  @Override
  public int hashCode() {
    return Objects.hash(createdBefore, createdAfter, startsAfter, startsBefore, valid, usable, redeemed, recipientIntegrationId, exactMatch, value, batchId, referralId, expiresAfter, expiresBefore);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CouponDeletionFilters {\n");
    sb.append("    createdBefore: ").append(toIndentedString(createdBefore)).append("\n");
    sb.append("    createdAfter: ").append(toIndentedString(createdAfter)).append("\n");
    sb.append("    startsAfter: ").append(toIndentedString(startsAfter)).append("\n");
    sb.append("    startsBefore: ").append(toIndentedString(startsBefore)).append("\n");
    sb.append("    valid: ").append(toIndentedString(valid)).append("\n");
    sb.append("    usable: ").append(toIndentedString(usable)).append("\n");
    sb.append("    redeemed: ").append(toIndentedString(redeemed)).append("\n");
    sb.append("    recipientIntegrationId: ").append(toIndentedString(recipientIntegrationId)).append("\n");
    sb.append("    exactMatch: ").append(toIndentedString(exactMatch)).append("\n");
    sb.append("    value: ").append(toIndentedString(value)).append("\n");
    sb.append("    batchId: ").append(toIndentedString(batchId)).append("\n");
    sb.append("    referralId: ").append(toIndentedString(referralId)).append("\n");
    sb.append("    expiresAfter: ").append(toIndentedString(expiresAfter)).append("\n");
    sb.append("    expiresBefore: ").append(toIndentedString(expiresBefore)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>(Arrays.asList("createdBefore", "createdAfter", "startsAfter", "startsBefore", "valid", "usable", "redeemed", "recipientIntegrationId", "exactMatch", "value", "batchId", "referralId", "expiresAfter", "expiresBefore"));

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>(0);
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to CouponDeletionFilters
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!CouponDeletionFilters.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format(Locale.ROOT, "The required field(s) %s in CouponDeletionFilters is not found in the empty JSON string", CouponDeletionFilters.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!CouponDeletionFilters.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format(Locale.ROOT, "The field `%s` in the JSON string is not defined in the `CouponDeletionFilters` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("valid") != null && !jsonObj.get("valid").isJsonNull()) && !jsonObj.get("valid").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format(Locale.ROOT, "Expected the field `valid` to be a primitive type in the JSON string but got `%s`", jsonObj.get("valid").toString()));
      }
      // validate the optional field `valid`
      if (jsonObj.get("valid") != null && !jsonObj.get("valid").isJsonNull()) {
        ValidEnum.validateJsonElement(jsonObj.get("valid"));
      }
      if ((jsonObj.get("recipientIntegrationId") != null && !jsonObj.get("recipientIntegrationId").isJsonNull()) && !jsonObj.get("recipientIntegrationId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format(Locale.ROOT, "Expected the field `recipientIntegrationId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("recipientIntegrationId").toString()));
      }
      if ((jsonObj.get("value") != null && !jsonObj.get("value").isJsonNull()) && !jsonObj.get("value").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format(Locale.ROOT, "Expected the field `value` to be a primitive type in the JSON string but got `%s`", jsonObj.get("value").toString()));
      }
      if ((jsonObj.get("batchId") != null && !jsonObj.get("batchId").isJsonNull()) && !jsonObj.get("batchId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format(Locale.ROOT, "Expected the field `batchId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("batchId").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!CouponDeletionFilters.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'CouponDeletionFilters' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<CouponDeletionFilters> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(CouponDeletionFilters.class));

       return (TypeAdapter<T>) new TypeAdapter<CouponDeletionFilters>() {
           @Override
           public void write(JsonWriter out, CouponDeletionFilters value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public CouponDeletionFilters read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of CouponDeletionFilters given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of CouponDeletionFilters
   * @throws IOException if the JSON string is invalid with respect to CouponDeletionFilters
   */
  public static CouponDeletionFilters fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, CouponDeletionFilters.class);
  }

  /**
   * Convert an instance of CouponDeletionFilters to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

