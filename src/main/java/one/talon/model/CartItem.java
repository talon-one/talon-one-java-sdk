/*
 * Talon.One API
 * Use the Talon.One API to integrate with your application and to manage applications and campaigns:  - Use the operations in the [Integration API section](#integration-api) are used to integrate with our platform - Use the operation in the [Management API section](#management-api) to manage applications and campaigns.  ## Determining the base URL of the endpoints  The API is available at the same hostname as your Campaign Manager deployment. For example, if you access the Campaign Manager at `https://yourbaseurl.talon.one/`, the URL for the [updateCustomerSessionV2](https://docs.talon.one/integration-api#operation/updateCustomerSessionV2) endpoint is `https://yourbaseurl.talon.one/v2/customer_sessions/{Id}` 
 *
 * The version of the OpenAPI document: 
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package one.talon.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.math.BigDecimal;
import java.time.OffsetDateTime;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import one.talon.model.AdditionalCost;
import one.talon.model.PriceDetail;
import one.talon.model.Product;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import one.talon.JSON;

/**
 * CartItem
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", comments = "Generator version: 7.13.0-SNAPSHOT")
public class CartItem {
  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  @javax.annotation.Nullable
  private String name;

  public static final String SERIALIZED_NAME_SKU = "sku";
  @SerializedName(SERIALIZED_NAME_SKU)
  @javax.annotation.Nonnull
  private String sku;

  public static final String SERIALIZED_NAME_QUANTITY = "quantity";
  @SerializedName(SERIALIZED_NAME_QUANTITY)
  @javax.annotation.Nonnull
  private Long quantity;

  public static final String SERIALIZED_NAME_RETURNED_QUANTITY = "returnedQuantity";
  @SerializedName(SERIALIZED_NAME_RETURNED_QUANTITY)
  @javax.annotation.Nullable
  private Long returnedQuantity;

  public static final String SERIALIZED_NAME_REMAINING_QUANTITY = "remainingQuantity";
  @SerializedName(SERIALIZED_NAME_REMAINING_QUANTITY)
  @javax.annotation.Nullable
  private Long remainingQuantity;

  public static final String SERIALIZED_NAME_PRICE = "price";
  @SerializedName(SERIALIZED_NAME_PRICE)
  @javax.annotation.Nullable
  private BigDecimal price;

  public static final String SERIALIZED_NAME_CATEGORY = "category";
  @SerializedName(SERIALIZED_NAME_CATEGORY)
  @javax.annotation.Nullable
  private String category;

  public static final String SERIALIZED_NAME_PRODUCT = "product";
  @SerializedName(SERIALIZED_NAME_PRODUCT)
  @javax.annotation.Nullable
  private Product product;

  public static final String SERIALIZED_NAME_WEIGHT = "weight";
  @SerializedName(SERIALIZED_NAME_WEIGHT)
  @javax.annotation.Nullable
  private BigDecimal weight;

  public static final String SERIALIZED_NAME_HEIGHT = "height";
  @SerializedName(SERIALIZED_NAME_HEIGHT)
  @javax.annotation.Nullable
  private BigDecimal height;

  public static final String SERIALIZED_NAME_WIDTH = "width";
  @SerializedName(SERIALIZED_NAME_WIDTH)
  @javax.annotation.Nullable
  private BigDecimal width;

  public static final String SERIALIZED_NAME_LENGTH = "length";
  @SerializedName(SERIALIZED_NAME_LENGTH)
  @javax.annotation.Nullable
  private BigDecimal length;

  public static final String SERIALIZED_NAME_POSITION = "position";
  @SerializedName(SERIALIZED_NAME_POSITION)
  @javax.annotation.Nullable
  private BigDecimal position;

  public static final String SERIALIZED_NAME_ATTRIBUTES = "attributes";
  @SerializedName(SERIALIZED_NAME_ATTRIBUTES)
  @javax.annotation.Nullable
  private Object attributes;

  public static final String SERIALIZED_NAME_ADDITIONAL_COSTS = "additionalCosts";
  @SerializedName(SERIALIZED_NAME_ADDITIONAL_COSTS)
  @javax.annotation.Nullable
  private Map<String, AdditionalCost> additionalCosts = new HashMap<>();

  public static final String SERIALIZED_NAME_CATALOG_ITEM_I_D = "catalogItemID";
  @SerializedName(SERIALIZED_NAME_CATALOG_ITEM_I_D)
  @javax.annotation.Nullable
  private Long catalogItemID;

  public static final String SERIALIZED_NAME_SELECTED_PRICE_TYPE = "selectedPriceType";
  @SerializedName(SERIALIZED_NAME_SELECTED_PRICE_TYPE)
  @javax.annotation.Nullable
  private String selectedPriceType;

  public static final String SERIALIZED_NAME_ADJUSTMENT_REFERENCE_ID = "adjustmentReferenceId";
  @SerializedName(SERIALIZED_NAME_ADJUSTMENT_REFERENCE_ID)
  @javax.annotation.Nullable
  private UUID adjustmentReferenceId;

  public static final String SERIALIZED_NAME_ADJUSTMENT_EFFECTIVE_FROM = "adjustmentEffectiveFrom";
  @SerializedName(SERIALIZED_NAME_ADJUSTMENT_EFFECTIVE_FROM)
  @javax.annotation.Nullable
  private OffsetDateTime adjustmentEffectiveFrom;

  public static final String SERIALIZED_NAME_ADJUSTMENT_EFFECTIVE_UNTIL = "adjustmentEffectiveUntil";
  @SerializedName(SERIALIZED_NAME_ADJUSTMENT_EFFECTIVE_UNTIL)
  @javax.annotation.Nullable
  private OffsetDateTime adjustmentEffectiveUntil;

  public static final String SERIALIZED_NAME_PRICES = "prices";
  @SerializedName(SERIALIZED_NAME_PRICES)
  @javax.annotation.Nullable
  private Map<String, PriceDetail> prices = new HashMap<>();

  public CartItem() {
  }

  public CartItem name(@javax.annotation.Nullable String name) {
    this.name = name;
    return this;
  }

  /**
   * Name of item.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(@javax.annotation.Nullable String name) {
    this.name = name;
  }


  public CartItem sku(@javax.annotation.Nonnull String sku) {
    this.sku = sku;
    return this;
  }

  /**
   * Stock keeping unit of item.
   * @return sku
   */
  @javax.annotation.Nonnull
  public String getSku() {
    return sku;
  }

  public void setSku(@javax.annotation.Nonnull String sku) {
    this.sku = sku;
  }


  public CartItem quantity(@javax.annotation.Nonnull Long quantity) {
    this.quantity = quantity;
    return this;
  }

  /**
   * Number of units of this item. Due to [cart item flattening](https://docs.talon.one/docs/product/rules/understanding-cart-item-flattening), if you provide a quantity greater than 1, the item will be split in as many items as the provided quantity. This will impact the number of **per-item** effects triggered from your campaigns. 
   * minimum: 1
   * @return quantity
   */
  @javax.annotation.Nonnull
  public Long getQuantity() {
    return quantity;
  }

  public void setQuantity(@javax.annotation.Nonnull Long quantity) {
    this.quantity = quantity;
  }


  public CartItem returnedQuantity(@javax.annotation.Nullable Long returnedQuantity) {
    this.returnedQuantity = returnedQuantity;
    return this;
  }

  /**
   * Number of returned items, calculated internally based on returns of this item.
   * @return returnedQuantity
   */
  @javax.annotation.Nullable
  public Long getReturnedQuantity() {
    return returnedQuantity;
  }

  public void setReturnedQuantity(@javax.annotation.Nullable Long returnedQuantity) {
    this.returnedQuantity = returnedQuantity;
  }


  public CartItem remainingQuantity(@javax.annotation.Nullable Long remainingQuantity) {
    this.remainingQuantity = remainingQuantity;
    return this;
  }

  /**
   * Remaining quantity of the item, calculated internally based on returns of this item.
   * @return remainingQuantity
   */
  @javax.annotation.Nullable
  public Long getRemainingQuantity() {
    return remainingQuantity;
  }

  public void setRemainingQuantity(@javax.annotation.Nullable Long remainingQuantity) {
    this.remainingQuantity = remainingQuantity;
  }


  public CartItem price(@javax.annotation.Nullable BigDecimal price) {
    this.price = price;
    return this;
  }

  /**
   * Price of the item in the currency defined by your Application. This field is required if this item is not part of a [catalog](https://docs.talon.one/docs/product/account/dev-tools/managing-cart-item-catalogs). If it is part of a catalog, setting a price here overrides the price from the catalog. 
   * @return price
   */
  @javax.annotation.Nullable
  public BigDecimal getPrice() {
    return price;
  }

  public void setPrice(@javax.annotation.Nullable BigDecimal price) {
    this.price = price;
  }


  public CartItem category(@javax.annotation.Nullable String category) {
    this.category = category;
    return this;
  }

  /**
   * Type, group or model of the item.
   * @return category
   */
  @javax.annotation.Nullable
  public String getCategory() {
    return category;
  }

  public void setCategory(@javax.annotation.Nullable String category) {
    this.category = category;
  }


  public CartItem product(@javax.annotation.Nullable Product product) {
    this.product = product;
    return this;
  }

  /**
   * Get product
   * @return product
   */
  @javax.annotation.Nullable
  public Product getProduct() {
    return product;
  }

  public void setProduct(@javax.annotation.Nullable Product product) {
    this.product = product;
  }


  public CartItem weight(@javax.annotation.Nullable BigDecimal weight) {
    this.weight = weight;
    return this;
  }

  /**
   * Weight of item in grams.
   * @return weight
   */
  @javax.annotation.Nullable
  public BigDecimal getWeight() {
    return weight;
  }

  public void setWeight(@javax.annotation.Nullable BigDecimal weight) {
    this.weight = weight;
  }


  public CartItem height(@javax.annotation.Nullable BigDecimal height) {
    this.height = height;
    return this;
  }

  /**
   * Height of item in mm.
   * @return height
   */
  @javax.annotation.Nullable
  public BigDecimal getHeight() {
    return height;
  }

  public void setHeight(@javax.annotation.Nullable BigDecimal height) {
    this.height = height;
  }


  public CartItem width(@javax.annotation.Nullable BigDecimal width) {
    this.width = width;
    return this;
  }

  /**
   * Width of item in mm.
   * @return width
   */
  @javax.annotation.Nullable
  public BigDecimal getWidth() {
    return width;
  }

  public void setWidth(@javax.annotation.Nullable BigDecimal width) {
    this.width = width;
  }


  public CartItem length(@javax.annotation.Nullable BigDecimal length) {
    this.length = length;
    return this;
  }

  /**
   * Length of item in mm.
   * @return length
   */
  @javax.annotation.Nullable
  public BigDecimal getLength() {
    return length;
  }

  public void setLength(@javax.annotation.Nullable BigDecimal length) {
    this.length = length;
  }


  public CartItem position(@javax.annotation.Nullable BigDecimal position) {
    this.position = position;
    return this;
  }

  /**
   * Position of the Cart Item in the Cart (calculated internally).
   * @return position
   */
  @javax.annotation.Nullable
  public BigDecimal getPosition() {
    return position;
  }

  public void setPosition(@javax.annotation.Nullable BigDecimal position) {
    this.position = position;
  }


  public CartItem attributes(@javax.annotation.Nullable Object attributes) {
    this.attributes = attributes;
    return this;
  }

  /**
   * Use this property to set a value for the attributes of your choice. [Attributes](https://docs.talon.one/docs/dev/concepts/attributes) represent any information to attach to this cart item.  Custom _cart item_ attributes must be created in the Campaign Manager before you set them with this property.  **Note:** Any previously defined attributes that you do not include in the array will be removed. 
   * @return attributes
   */
  @javax.annotation.Nullable
  public Object getAttributes() {
    return attributes;
  }

  public void setAttributes(@javax.annotation.Nullable Object attributes) {
    this.attributes = attributes;
  }


  public CartItem additionalCosts(@javax.annotation.Nullable Map<String, AdditionalCost> additionalCosts) {
    this.additionalCosts = additionalCosts;
    return this;
  }

  public CartItem putAdditionalCostsItem(String key, AdditionalCost additionalCostsItem) {
    if (this.additionalCosts == null) {
      this.additionalCosts = new HashMap<>();
    }
    this.additionalCosts.put(key, additionalCostsItem);
    return this;
  }

  /**
   * Use this property to set a value for the additional costs of this item, such as a shipping cost. They must be created in the Campaign Manager before you set them with this property. See [Managing additional costs](https://docs.talon.one/docs/product/account/dev-tools/managing-additional-costs). 
   * @return additionalCosts
   */
  @javax.annotation.Nullable
  public Map<String, AdditionalCost> getAdditionalCosts() {
    return additionalCosts;
  }

  public void setAdditionalCosts(@javax.annotation.Nullable Map<String, AdditionalCost> additionalCosts) {
    this.additionalCosts = additionalCosts;
  }


  public CartItem catalogItemID(@javax.annotation.Nullable Long catalogItemID) {
    this.catalogItemID = catalogItemID;
    return this;
  }

  /**
   * The catalog item ID.
   * @return catalogItemID
   */
  @javax.annotation.Nullable
  public Long getCatalogItemID() {
    return catalogItemID;
  }

  public void setCatalogItemID(@javax.annotation.Nullable Long catalogItemID) {
    this.catalogItemID = catalogItemID;
  }


  public CartItem selectedPriceType(@javax.annotation.Nullable String selectedPriceType) {
    this.selectedPriceType = selectedPriceType;
    return this;
  }

  /**
   * The selected price type for this cart item (e.g. the price for members only).
   * @return selectedPriceType
   */
  @javax.annotation.Nullable
  public String getSelectedPriceType() {
    return selectedPriceType;
  }

  public void setSelectedPriceType(@javax.annotation.Nullable String selectedPriceType) {
    this.selectedPriceType = selectedPriceType;
  }


  public CartItem adjustmentReferenceId(@javax.annotation.Nullable UUID adjustmentReferenceId) {
    this.adjustmentReferenceId = adjustmentReferenceId;
    return this;
  }

  /**
   * The reference ID of the selected price adjustment for this cart item. Only returned if the selected price resulted from a price adjustment.
   * @return adjustmentReferenceId
   */
  @javax.annotation.Nullable
  public UUID getAdjustmentReferenceId() {
    return adjustmentReferenceId;
  }

  public void setAdjustmentReferenceId(@javax.annotation.Nullable UUID adjustmentReferenceId) {
    this.adjustmentReferenceId = adjustmentReferenceId;
  }


  public CartItem adjustmentEffectiveFrom(@javax.annotation.Nullable OffsetDateTime adjustmentEffectiveFrom) {
    this.adjustmentEffectiveFrom = adjustmentEffectiveFrom;
    return this;
  }

  /**
   * The date and time from which the price adjustment is effective. Only returned if the selected price resulted from a price adjustment that contains this field.
   * @return adjustmentEffectiveFrom
   */
  @javax.annotation.Nullable
  public OffsetDateTime getAdjustmentEffectiveFrom() {
    return adjustmentEffectiveFrom;
  }

  public void setAdjustmentEffectiveFrom(@javax.annotation.Nullable OffsetDateTime adjustmentEffectiveFrom) {
    this.adjustmentEffectiveFrom = adjustmentEffectiveFrom;
  }


  public CartItem adjustmentEffectiveUntil(@javax.annotation.Nullable OffsetDateTime adjustmentEffectiveUntil) {
    this.adjustmentEffectiveUntil = adjustmentEffectiveUntil;
    return this;
  }

  /**
   * The date and time until which the price adjustment is effective. Only returned if the selected price resulted from a price adjustment that contains this field.
   * @return adjustmentEffectiveUntil
   */
  @javax.annotation.Nullable
  public OffsetDateTime getAdjustmentEffectiveUntil() {
    return adjustmentEffectiveUntil;
  }

  public void setAdjustmentEffectiveUntil(@javax.annotation.Nullable OffsetDateTime adjustmentEffectiveUntil) {
    this.adjustmentEffectiveUntil = adjustmentEffectiveUntil;
  }


  public CartItem prices(@javax.annotation.Nullable Map<String, PriceDetail> prices) {
    this.prices = prices;
    return this;
  }

  public CartItem putPricesItem(String key, PriceDetail pricesItem) {
    if (this.prices == null) {
      this.prices = new HashMap<>();
    }
    this.prices.put(key, pricesItem);
    return this;
  }

  /**
   * A map of keys and values representing the price types and related price adjustment details for this cart item. The keys correspond to the &#x60;priceType&#x60; names. 
   * @return prices
   */
  @javax.annotation.Nullable
  public Map<String, PriceDetail> getPrices() {
    return prices;
  }

  public void setPrices(@javax.annotation.Nullable Map<String, PriceDetail> prices) {
    this.prices = prices;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    CartItem cartItem = (CartItem) o;
    return Objects.equals(this.name, cartItem.name) &&
        Objects.equals(this.sku, cartItem.sku) &&
        Objects.equals(this.quantity, cartItem.quantity) &&
        Objects.equals(this.returnedQuantity, cartItem.returnedQuantity) &&
        Objects.equals(this.remainingQuantity, cartItem.remainingQuantity) &&
        Objects.equals(this.price, cartItem.price) &&
        Objects.equals(this.category, cartItem.category) &&
        Objects.equals(this.product, cartItem.product) &&
        Objects.equals(this.weight, cartItem.weight) &&
        Objects.equals(this.height, cartItem.height) &&
        Objects.equals(this.width, cartItem.width) &&
        Objects.equals(this.length, cartItem.length) &&
        Objects.equals(this.position, cartItem.position) &&
        Objects.equals(this.attributes, cartItem.attributes) &&
        Objects.equals(this.additionalCosts, cartItem.additionalCosts) &&
        Objects.equals(this.catalogItemID, cartItem.catalogItemID) &&
        Objects.equals(this.selectedPriceType, cartItem.selectedPriceType) &&
        Objects.equals(this.adjustmentReferenceId, cartItem.adjustmentReferenceId) &&
        Objects.equals(this.adjustmentEffectiveFrom, cartItem.adjustmentEffectiveFrom) &&
        Objects.equals(this.adjustmentEffectiveUntil, cartItem.adjustmentEffectiveUntil) &&
        Objects.equals(this.prices, cartItem.prices);
  }

  @Override
  public int hashCode() {
    return Objects.hash(name, sku, quantity, returnedQuantity, remainingQuantity, price, category, product, weight, height, width, length, position, attributes, additionalCosts, catalogItemID, selectedPriceType, adjustmentReferenceId, adjustmentEffectiveFrom, adjustmentEffectiveUntil, prices);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CartItem {\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    sku: ").append(toIndentedString(sku)).append("\n");
    sb.append("    quantity: ").append(toIndentedString(quantity)).append("\n");
    sb.append("    returnedQuantity: ").append(toIndentedString(returnedQuantity)).append("\n");
    sb.append("    remainingQuantity: ").append(toIndentedString(remainingQuantity)).append("\n");
    sb.append("    price: ").append(toIndentedString(price)).append("\n");
    sb.append("    category: ").append(toIndentedString(category)).append("\n");
    sb.append("    product: ").append(toIndentedString(product)).append("\n");
    sb.append("    weight: ").append(toIndentedString(weight)).append("\n");
    sb.append("    height: ").append(toIndentedString(height)).append("\n");
    sb.append("    width: ").append(toIndentedString(width)).append("\n");
    sb.append("    length: ").append(toIndentedString(length)).append("\n");
    sb.append("    position: ").append(toIndentedString(position)).append("\n");
    sb.append("    attributes: ").append(toIndentedString(attributes)).append("\n");
    sb.append("    additionalCosts: ").append(toIndentedString(additionalCosts)).append("\n");
    sb.append("    catalogItemID: ").append(toIndentedString(catalogItemID)).append("\n");
    sb.append("    selectedPriceType: ").append(toIndentedString(selectedPriceType)).append("\n");
    sb.append("    adjustmentReferenceId: ").append(toIndentedString(adjustmentReferenceId)).append("\n");
    sb.append("    adjustmentEffectiveFrom: ").append(toIndentedString(adjustmentEffectiveFrom)).append("\n");
    sb.append("    adjustmentEffectiveUntil: ").append(toIndentedString(adjustmentEffectiveUntil)).append("\n");
    sb.append("    prices: ").append(toIndentedString(prices)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("name");
    openapiFields.add("sku");
    openapiFields.add("quantity");
    openapiFields.add("returnedQuantity");
    openapiFields.add("remainingQuantity");
    openapiFields.add("price");
    openapiFields.add("category");
    openapiFields.add("product");
    openapiFields.add("weight");
    openapiFields.add("height");
    openapiFields.add("width");
    openapiFields.add("length");
    openapiFields.add("position");
    openapiFields.add("attributes");
    openapiFields.add("additionalCosts");
    openapiFields.add("catalogItemID");
    openapiFields.add("selectedPriceType");
    openapiFields.add("adjustmentReferenceId");
    openapiFields.add("adjustmentEffectiveFrom");
    openapiFields.add("adjustmentEffectiveUntil");
    openapiFields.add("prices");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("sku");
    openapiRequiredFields.add("quantity");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to CartItem
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!CartItem.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in CartItem is not found in the empty JSON string", CartItem.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!CartItem.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `CartItem` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : CartItem.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if (!jsonObj.get("sku").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sku` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sku").toString()));
      }
      if ((jsonObj.get("category") != null && !jsonObj.get("category").isJsonNull()) && !jsonObj.get("category").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `category` to be a primitive type in the JSON string but got `%s`", jsonObj.get("category").toString()));
      }
      // validate the optional field `product`
      if (jsonObj.get("product") != null && !jsonObj.get("product").isJsonNull()) {
        Product.validateJsonElement(jsonObj.get("product"));
      }
      if ((jsonObj.get("selectedPriceType") != null && !jsonObj.get("selectedPriceType").isJsonNull()) && !jsonObj.get("selectedPriceType").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `selectedPriceType` to be a primitive type in the JSON string but got `%s`", jsonObj.get("selectedPriceType").toString()));
      }
      if ((jsonObj.get("adjustmentReferenceId") != null && !jsonObj.get("adjustmentReferenceId").isJsonNull()) && !jsonObj.get("adjustmentReferenceId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `adjustmentReferenceId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("adjustmentReferenceId").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!CartItem.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'CartItem' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<CartItem> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(CartItem.class));

       return (TypeAdapter<T>) new TypeAdapter<CartItem>() {
           @Override
           public void write(JsonWriter out, CartItem value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public CartItem read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of CartItem given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of CartItem
   * @throws IOException if the JSON string is invalid with respect to CartItem
   */
  public static CartItem fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, CartItem.class);
  }

  /**
   * Convert an instance of CartItem to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

